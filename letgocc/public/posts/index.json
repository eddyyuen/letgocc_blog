[{"content":"本文翻译自原文： Faster time parsing\n作者： Phil Pearl\n在Ravelin，我们有大量的数据，有大量的时间戳。大多数时间戳在 BigQuery 中被存储为字符串，而我们的大多数 Go 结构用 Go time.Time 类型表示时间。\n我很遗憾地说出上述这些事实。我们确实有大量的数据。而且我们确实有很多时间戳。一段时间以来，我一直在围着一个结论打转，随着时间的推移，我确信我将会朝着这个结论落下。\n朋友不会让朋友在数据库中用字符串表示时间。\n无论如何，决定已经做出，我们被它们所困。但被决定所困并不意味着我们被所有不幸的后果所困。我们可以把事情做到最好。对我来说，现在把事情做到最好不可避免地包括找到一种比使用time.Parse更快的方法来解析 RFC3339 时间戳。\n事实证明这很容易。time.Parse有两个参数：一个是描述要解析的数据的格式，另一个是需要解析的数据字符串。格式参数并不只是选择适合该格式的专用解析程序。格式参数描述了应该如何解析数据。time.Parse不仅要解析时间，而且要解析、理解和实现对如何解析时间的描述。如果我们写一个专门的解析例程，只解析 RFC3339，应该比这更快。\n但在我们开始之前，让我们写一个快速的基准测试来看看time.Parse有多快。\nfunc BenchmarkParseRFC3339(b *testing.B) { now := time.Now().UTC().Format(time.RFC3339Nano) for i := 0; i \u0026lt; b.N; i++ { if _, err := time.Parse(time.RFC3339, now); err != nil { b.Fatal(err) } } } 以下是结果\nname time/op ParseRFC3339-16 150ns ± 1% 现在我们可以编写我们专用的 RFC3339 解析函数了。这很无聊。它不漂亮。但是（据我所知！）它有效。\n(它确实很长，也不漂亮，所以与其把它放在这篇文章里，让你们都滑过去，不如在这里提供一个链接，让你们看到应用了下面讨论的所有优化的最终版本。如果你想象一下一个很长的函数，其中有很多对strconv.Atoi的调用，你就会明白的)\n如果我们调整我们的基准以使用我们新的解析函数，我们会得到以下结果。\nname old time/op new time/op delta ParseRFC3339-16 150ns ± 1% 45ns ± 4% -70.15% (p=0.000 n=7+8) 它确实比time.Time快了不少。很好。我们完成了。\n当然，我们还没有完成。\n如果我们得到一个 CPU 配置文件，我们就会发现很多时间是在调用strconv.Atoi时消耗的。\n\u0026gt; go test -run ^$ -bench BenchmarkParseRFC3339 -cpuprofile cpu.prof \u0026gt; go tool pprof cpu.prof Type: cpu Time: Oct 1, 2021 at 7:19pm (BST) Duration: 1.22s, Total samples = 960ms (78.50%) Entering interactive mode (type \u0026quot;help\u0026quot; for commands, \u0026quot;o\u0026quot; for options) (pprof) top Showing nodes accounting for 950ms, 98.96% of 960ms total Showing top 10 nodes out of 24 flat flat% sum% cum cum% 380ms 39.58% 39.58% 380ms 39.58% strconv.Atoi 370ms 38.54% 78.12% 920ms 95.83% github.com/philpearl/blog/content/post.parseTime 60ms 6.25% 84.38% 170ms 17.71% time.Date strconv.Atoi将 ASCII 字符串中的数字转换为整数。这是 Go 标准库的一个基本部分，所以它的编码肯定非常好，而且已经被优化了。当然，我们不能在此基础上进行改进？\n好吧，我们的大多数数字都正好是 2 字节长或 4 字节长。我们可以利用这些事实来编写数字解析函数，而不需要那些讨厌的慢速 for 循环。\nfunc atoi2(in string) (int, error) { a, b := int(in[0]-'0'), int(in[1]-'0') if a \u0026lt; 0 || a \u0026gt; 9 || b \u0026lt; 0 || b \u0026gt; 9 { return 0, fmt.Errorf(\u0026quot;can't parse number %q\u0026quot;, in) } return a*10 + b, nil } func atoi4(in string) (int, error) { a, b, c, d := int(in[0]-'0'), int(in[1]-'0'), int(in[2]-'0'), int(in[3]-'0') if a \u0026lt; 0 || a \u0026gt; 9 || b \u0026lt; 0 || b \u0026gt; 9 || c \u0026lt; 0 || c \u0026gt; 9 || d \u0026lt; 0 || d \u0026gt; 9 { return 0, fmt.Errorf(\u0026quot;can't parse number %q\u0026quot;, in) } return a*1000 + b*100 + c*10 + d, nil } 如果我们再次运行我们的基准测试，我们可以看到我们已经取得了很好的进一步改进。\nname old time/op new time/op delta ParseRFC3339-16 44.9ns ± 4% 39.7ns ± 3% -11.51% (p=0.000 n=8+8) 好了，我们现在不仅写了一个自定义的时间分析器，而且还写了自定义的数字分析器。这肯定够了。现在肯定是完成了。\n当然，我们还没有完成。\n啊，但是让我们再看一下 CPU 配置文件。再让我们看看反汇编。在atoi2中有两个切片长度检查（它们是对 panicIndex 的调用，在下面的绿色反汇编中看到）。这不是有一个技巧吗？\n下面是用这个技巧更新的代码。_ = in[1]在函数的开头给了编译器足够的提示，它不会在我们以后每次引用它时都检查字符串是否足够长。\nfunc atoi2(in string) (int, error) { _ = in[1] // This helps the compiler reduce the number of times it checks `in` is long enough a, b := int(in[0]-'0'), int(in[1]-'0') if a \u0026lt; 0 || a \u0026gt; 9 || b \u0026lt; 0 || b \u0026gt; 9 { return 0, fmt.Errorf(\u0026quot;can't parse number %q\u0026quot;, in) } return a*10 + b, nil } 一个小小的改变，但足以让我们有一个明确的改善\nname old time/op new time/op delta ParseRFC3339-16 39.7ns ± 3% 38.4ns ± 2% -3.26% (p=0.001 n=8+7) atoi2非常短。为什么它不被内联？也许如果我们简化错误，它就会被简化？如果我们去掉对fmt.Errorf的调用，用一个简单的错误来代替它，这就降低了我们 atoi 函数的复杂性。这可能足以让 Go 编译器决定不把这些函数作为单独的代码块来实现，而是直接在调用函数中实现。\nvar errNotNumber = errors.New(\u0026quot;not a valid number\u0026quot;) func atoi2(in string) (int, error) { _ = in[1] a, b := int(in[0]-'0'), int(in[1]-'0') if a \u0026lt; 0 || a \u0026gt; 9 || b \u0026lt; 0 || b \u0026gt; 9 { return 0, errNotNumber } return a*10 + b, nil } 事实的确如此，并产生了明显的改进。\nname old time/op new time/op delta ParseRFC3339-16 38.4ns ± 2% 32.9ns ± 5% -14.39% (p=0.000 n=7+8) 我们的故事就到此为止了。在大约 120 纳秒的时间里做了很多工作。但是，纳秒加起来，这些改进使 Ravelin 的一些机器学习特征提取管道的运行时间减少了一个小时或更多。正如我所说，我们确实有大量的数据和大量的时间戳!\n","description":"","id":0,"section":"posts","tags":["golang"],"title":"Faster Time Parse","uri":"https://letgo.cc/posts/go/2022-02-16-faster-time-parse/"},{"content":"很好 啊啊\n22 22.1 ","description":"hahah","id":1,"section":"posts","tags":["flag"],"title":"2022 Plan","uri":"https://letgo.cc/posts/2022-02-17-plan/"},{"content":"语句类别 本期介绍 checked, unchecked, fixed, lock 关键字\n   类别 C#关键字     选择语句 if、else、switch、case   迭代语句 do、for、foreach、in、while   跳转语句 break、continue、default、goto、return、yield   异常处理语句 throw、try-catch、try-finally、try-catch-finally   Checked 和 unchecked checked、unchecked   fixed 语句 fixed   lock 语句 lock    checked  checked 关键字用于对整型类型算术运算和转换显式启用溢出检查。\n 一般我们在运行时，进行整型的运算时，是不会进行溢出检查的。例如\n1 2 3 4 5 6  int a = 27; //int b = 2147483648; 超出目标范围外，编译异常 int b = int.MaxValue; //2147483647 int c = a + b; Console.Write($\u0026#34;{c} \u0026#34;); //output -2147483622   相加的数值因为超出 2147483647，以负数 -2147483622 展示。很明显这不是我们想要的结果。那么我们加上checked关键字进行溢出检查\n1 2 3 4 5 6  checked{ int c = a + b; Console.Write($\u0026#34;{c}\u0026#34;); } 或者 int c = checked(a + b);   运行时会抛出异常 System.OverflowException:“Arithmetic operation resulted in an overflow.”\nVisual Studio 启用溢出检查  打开项目属性页 打开生成属性页 点击 高级 按钮 勾选检查算术溢出属性  unchecked 跟checked关键字相反， unchecked关键字取消运行时的溢出检查。原因在于检查溢出需要时间，在没有溢出风险时取消检查可以提高程序的性能。\nfixed 在了解fixed之前要先了解 CLR。\nCLR管理着一块连续的地址空间。当没有足够的地址空间来分配新建的对象时，就会触发GC。GC 时，会删除垃圾对象，并把非垃圾对象移动到大的连续的内存块里面以压缩这个地址空间。这时，指向这些对象的指针就会失效。GC会自行修改对象移动后的指针地址。\n但是！但是！这个是在托管环境下的代码，如果是 unsafe 代码下的指针，GC 是不会理会的！这样GC后就会造成 unsafe 代码失效。\n所以，我们需要用到 fixed 关键字，不允许垃圾回收器移动我们的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Point { public int x; public int y; } unsafe private static void ModifyFixedStorage() { // Variable pt is a managed variable, subject to garbage collection.  Point pt = new Point(); // Using fixed allows the address of pt members to be taken,  // and \u0026#34;pins\u0026#34; pt so that it is not relocated.  fixed (int* p = \u0026amp;pt.x) { *p = 1; } }   System.Span\u0026lt;T\u0026gt; 和 System.ReadOnlySpan\u0026lt;T\u0026gt; 也可以被固定。\n1 2 3 4 5 6 7 8 9 10 11  Span\u0026lt;int\u0026gt; RowFive = new Span\u0026lt;int\u0026gt;(PascalsTriangle, 10, 5); fixed (int* ptrToRow = RowFive) { // Sum the numbers 1,4,6,4,1  var sum = 0; for (int i = 0;i \u0026lt; RowFive.Length;i++) { sum += *(ptrToRow + i); } Console.WriteLine(sum); }   更多使用方法请查看fixed 关键字参考。\nlock lock 获取指定对象的互斥锁，执行语句块，然后释放锁。\n锁定对象 避免使用以下对象\n lock(this)\nthis 可能是两个不同的实例 lock(MyType)\n可以用 lock(typeof(MyType))。但是也不建议使用，因为typeof(MyType)范围有可能很大 lock(string)\nstring实例有可能只是暂时存在的  建议使用非public的专用于锁定的对象实例。\n1  private readonly object myLock = new object();   ","description":"","id":2,"section":"posts","tags":["dotnet","keyword"],"title":"C# 语句关键字（四）：checked, unchecked","uri":"https://letgo.cc/posts/dotnet/keyword/checked_unchecked/"},{"content":"语句类别 本期介绍 goto, yield 关键字\n   类别 C#关键字     选择语句 if、else、switch、case   迭代语句 do、for、foreach、in、while   跳转语句 break、continue、default、goto、return、yield   异常处理语句 throw、try-catch、try-finally、try-catch-finally   Checked 和 unchecked checked、unchecked   fixed 语句 fixed   lock 语句 lock    goto 直接跳转到标记语句 1 2 3 4 5 6 7 8 9 10  int val = 10; if(val is int) goto FoundInt; else goto Finish; FoundInt: Console.WriteLine(\u0026#34;Found Integer\u0026#34;); Finish: Console.WriteLine(\u0026#34;Finish\u0026#34;);   跳转到特定的 case 标签或 default 标签。 1 2 3 4 5 6 7 8 9 10 11  switch (n) { case 1: break; case 2: goto case 1; case 3: goto default; default: break; }   跳出多层嵌套循环。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  for (int i = 0; i \u0026lt; x; i++) { for (int j = 0; j \u0026lt; y; j++) { if (array[i, j].Equals(myNumber)) { goto FoundInt; } } } goto Finish; FoundInt: Console.WriteLine(\u0026#34;Found Integer\u0026#34;); Finish: Console.WriteLine(\u0026#34;Finish\u0026#34;);   yield yield 同时也属于上下文关键字。\nyield 出现在迭代器内部。\nyield return yield return 表示下一次迭代要返回的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13  foreach (int i in test()) { Console.Write(\u0026#34;{0} \u0026#34;, i); } public static IEnumerable\u0026lt;int\u0026gt; test() { int result = 0; for (int i = 0; i \u0026lt; 10; i++) { result = result + i; yield return result; } }   另外一种应用,可轻松实现可枚举的对象 Cities,Users\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static IEnumerable\u0026lt;string\u0026gt; Cities() { yield return \u0026#34;GUANGDONG\u0026#34;; yield return \u0026#34;BEIJING\u0026#34;; yield return \u0026#34;SHANGHAI\u0026#34;; yield return \u0026#34;SHENZHEN\u0026#34;; } public static IEnumerable\u0026lt;User\u0026gt; Users() { yield return new User { UserId = \u0026#34;1\u0026#34;, UserName = \u0026#34;GUANGDONG\u0026#34; }; yield return new User { UserId = \u0026#34;2\u0026#34;, UserName = \u0026#34;BEIJING\u0026#34; }; yield return new User { UserId = \u0026#34;3\u0026#34;, UserName = \u0026#34;SHANGHAI\u0026#34; }; yield return new User { UserId = \u0026#34;4\u0026#34;, UserName = \u0026#34;SHENZHEN\u0026#34; }; } public class User { public string UserName {get;set;} public string UserId { get; set; } }   yield break 在遇到 yield break; 便会终止迭代。\n1 2 3 4 5 6 7 8  public static IEnumerable\u0026lt;string\u0026gt; Cities() { yield return \u0026#34;GUANGDONG\u0026#34;; yield return \u0026#34;BEIJING\u0026#34;; yield return \u0026#34;SHANGHAI\u0026#34;; yield break; yield return \u0026#34;SHENZHEN\u0026#34;; }   ","description":"","id":3,"section":"posts","tags":["dotnet","keyword"],"title":"C# 语句关键字（三）：goto, yield","uri":"https://letgo.cc/posts/dotnet/keyword/goto_yield/"},{"content":"语句类别 本期介绍 for、foreach、in 关键字\n   类别 C#关键字     选择语句 if、else、switch、case   迭代语句 do、for、foreach、in、while   跳转语句 break、continue、default、goto、return、yield   异常处理语句 throw、try-catch、try-finally、try-catch-finally   Checked 和 unchecked checked、unchecked   fixed 语句 fixed   lock 语句 lock    for 一般我们使用 for(int i=0;i\u0026lt;100;i++) 这样的语句。但是实际上。在初始化、迭代器两个部分都可以调用其他方法。这是因为，在初始化、迭代器可以包括由逗号分割的零个或多个语句\n1 2 3 4 5 6 7  int i; int j = 10; for (i = 0, Console.WriteLine($\u0026#34;Start: i={i}, j={j}\u0026#34;); i \u0026lt; j; i++, j--, Console.WriteLine($\u0026#34;Step: i={i}, j={j}\u0026#34;)) { // Body of the loop. }   foreach , in foreach 语句为类型实例中实现 System.Collections.IEnumerable 或 System.Collections.Generic.IEnumerable\u0026lt; T\u0026gt; 接口的每个元素执行语句或语句块\n1 2 3 4 5 6 7 8  var fibNumbers = new List\u0026lt;int\u0026gt; { 0, 1, 1, 2, 3, 5, 8, 13 }; int count = 0; foreach (int element in fibNumbers) { Console.WriteLine($\u0026#34;Element #{count}: {element}\u0026#34;); count++; } Console.WriteLine($\u0026#34;Number of elements: {count}\u0026#34;);   foreach 语句还可以与满足以下条件的任何类型的实例一起使用：\n 类型具有公共无参数 GetEnumerator 方法，其返回类型为类、结构或接口类型。 从 C# 9.0 开始，GetEnumerator 方法可以是类型的扩展方法。 GetEnumerator 方法的返回类型具有公共 Current 属性和公共无参数 MoveNext 方法（其返回类型为 Boolean）。  示例\n1 2 3 4 5 6 7 8 9 10 11  class Program { static void Main(string[] args) { foreach (int number in 5) { Console.Write($\u0026#34;{number} \u0026#34;); } Console.ReadLine(); } }   输出结果 4 3 2 1 0。\n之所以能这样做是因为我们基于 C# 9.0 实现了 int 的扩展方法 GetEnumerator:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static Enumerator GetEnumerator(this int val) { var enumerator = new Enumerator(); enumerator.Current = val; return enumerator; } public struct Enumerator { public int Current { get; set; } public bool MoveNext() { if (Current \u0026lt;= 0) return false; Current -= 1; return true; } }   ref readonly 从 C# 7.3 开始，如果枚举器的 Current 属性返回引用返回值（ref T，其中 T 为集合元素类型），就可以使用 ref 或 ref readonly 修饰符来声明迭代变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class ForeachRefExample { public static void Main() { Span\u0026lt;int\u0026gt; storage = stackalloc int[10]; int num = 0; foreach (ref int item in storage) { item = num++; } foreach (ref readonly var item in storage) { Console.Write($\u0026#34;{item} \u0026#34;); } // Output:  // 0 1 2 3 4 5 6 7 8 9  } }   await foreach 从 C# 8.0 开始，可以使用 await foreach 语句来使用异步数据流，即实现 IAsyncEnumerable\u0026lt; T \u0026gt; 接口的集合类型。 异步检索下一个元素时，可能会挂起循环的每次迭代。\nC# 8.0 的 await foreach 后续有需要的话单独再介绍。\n1 2 3 4  await foreach (var item in GenerateSequenceAsync()) { Console.WriteLine(item); }   ","description":"","id":4,"section":"posts","tags":["dotnet","keyword"],"title":"C# 语句关键字（二）：for, foreach in","uri":"https://letgo.cc/posts/dotnet/keyword/for_foreach_in/"},{"content":"介绍 语句就是我们所说的程序指令。一般语句都是按照顺序执行的，除非遇到下表中介绍的关键字。\n语句类别    类别 C#关键字     选择语句 if、else、switch、case   迭代语句 do、for、foreach、in、while   跳转语句 break、continue、default、goto、return、yield   异常处理语句 throw、try-catch、try-finally、try-catch-finally   Checked 和 unchecked checked、unchecked   fixed 语句 fixed   lock 语句 lock    switch  switch 是一个选择语句，它根据与匹配表达式匹配的模式，从候选列表中选择单个开关部分进行执行。\n Case 标签 switch 语句包含至少一个开关，每个开关包含至少一个 case 标签。\n每个 case 标签指定一个模式与匹配表达式进行比较。 如果它们匹配，则执行首次匹配 case 标签的开关部分\n因为 C# 6 仅支持常量模式且禁止重复常量值，所以 case 标签定义了互斥值，而且只能有一个模式与匹配表达式匹配。 因此，case 语句显示的顺序并不重要。\n然而，在 C# 7.0 中，因为支持其他模式，所以 case 标签不需要定义互斥值，并且多个模式可以与匹配表达式相匹配。 因为仅执行包含匹配模式的首次开关部分中的语句，所以 case 语句显示的顺序很重要。\n以下示例说明了使用各种非互斥模式的 switch 语句。 如果你移动 case 0: switch 部分，使之不再是 switch 语句中的第一部分，C# 会生成编译器错误，因为值为零的整数是所有整数的子集（由 case int val 语句定义的模式）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // Calculate the sum of n dice rolls. public static int DiceSum(IEnumerable\u0026lt;object\u0026gt; values) { ar sum = 0; foreach (var item in values) { switch (item) { // A single zero value.  case 0: break; // A single value.  case int val: sum += val; break; // A non-empty collection.  case IEnumerable\u0026lt;object\u0026gt; subList when subList.Any(): sum += DiceSum(subList); break; // An empty collection.  case IEnumerable\u0026lt;object\u0026gt; subList: break; // A null reference.  case null: break; // A value that is neither an integer nor a collection.  default: throw new InvalidOperationException(\u0026#34;unknown item type\u0026#34;); } } return sum; }   你可以通过以下两种方法之一更正此问题并消除编译器警告：\n 更改开关部分的顺序。 在 case 标签中使用 when 子句。  模式匹配：类型模式 1  case type varname   其中 type 是 expr 结果要转换到的类型的名称，varname 是 expr 结果要转换到的对象（如果匹配成功）。\n如果以下任一条件成立，则 case 表达式为 true：\n expr 是与 type 具有相同类型的一个实例。 expr 是派生自 type 的类型的一个实例。 换言之，expr 结果可以向上转换为 type 的一个实例。 expr 具有属于 type 的一个基类的编译时类型，expr 还具有属于 type 或派生自 type 的运行时类型。 变量的编译时类型是其类型声明中定义的变量类型。 变量的运行时类型是分配给该变量的实例类型。 expr 是实现 type 接口的类型的一个实例。  请注意，null 与任何类型都不匹配。 若要匹配 null，请使用以下 case 标签：\n1  case null:   示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  switch (coll) { case Array arr: Console.WriteLine($\u0026#34;An array with {arr.Length} elements.\u0026#34;); break; case IEnumerable\u0026lt;int\u0026gt; ieInt: Console.WriteLine($\u0026#34;Average: {ieInt.Average(s =\u0026gt; s)}\u0026#34;); break; case IList list: Console.WriteLine($\u0026#34;{list.Count} items\u0026#34;); break; case IEnumerable ie: string result = \u0026#34;\u0026#34;; foreach (var e in ie) result += $\u0026#34;{e} \u0026#34;; Console.WriteLine(result); break; case null: // Do nothing for a null.  break; default: Console.WriteLine($\u0026#34;A instance of type {coll.GetType().Name}\u0026#34;); break; }   如果 coll 是泛型，将不能使用 case null 。因为编译器只能将 T 转换为 object 。\nwhen 子句 从 C# 7.0 开始，因为 case 语句不需要互相排斥，因此可以添加 when 子句来指定必须满足的附加条件使 case 语句计算为 true。 when 子句可以是返回布尔值的任何表达式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  private static void ShowShapeInfo(Shape sh) { switch (sh) { // Note that this code never evaluates to true.  case Shape shape when shape == null: Console.WriteLine($\u0026#34;An uninitialized shape (shape == null)\u0026#34;); break; case null: Console.WriteLine($\u0026#34;An uninitialized shape\u0026#34;); break; case Shape shape when sh.Area == 0: Console.WriteLine($\u0026#34;The shape: {sh.GetType().Name} with no dimensions\u0026#34;); break; case Square sq when sh.Area \u0026gt; 0: Console.WriteLine(\u0026#34;Information about square:\u0026#34;); Console.WriteLine($\u0026#34; Length of a side: {sq.Side}\u0026#34;); Console.WriteLine($\u0026#34; Area: {sq.Area}\u0026#34;); break; case Rectangle r when r.Length == r.Width \u0026amp;\u0026amp; r.Area \u0026gt; 0: Console.WriteLine(\u0026#34;Information about square rectangle:\u0026#34;); Console.WriteLine($\u0026#34; Length of a side: {r.Length}\u0026#34;); Console.WriteLine($\u0026#34; Area: {r.Area}\u0026#34;); break; case Rectangle r when sh.Area \u0026gt; 0: Console.WriteLine(\u0026#34;Information about rectangle:\u0026#34;); Console.WriteLine($\u0026#34; Dimensions: {r.Length} x {r.Width}\u0026#34;); Console.WriteLine($\u0026#34; Area: {r.Area}\u0026#34;); break; case Shape shape when sh != null: Console.WriteLine($\u0026#34;A {sh.GetType().Name} shape\u0026#34;); break; default: Console.WriteLine($\u0026#34;The {nameof(sh)} variable does not represent a Shape.\u0026#34;); break; } }   请注意，不会执行尝试测试 Shape 对象是否为 null 的示例中的 when 子句。 测试是否为 null 的正确类型模式是 case null:。\nswitch 表达式 (C# 8.0 ) 常量模式\n1 2 3 4 5 6 7 8 9 10 11  var direction = Directions.Right; Console.WriteLine($\u0026#34;Map view direction is {direction}\u0026#34;); var orientation = direction switch { Directions.Up =\u0026gt; Orientation.North, Directions.Right =\u0026gt; Orientation.East, Directions.Down =\u0026gt; Orientation.South, Directions.Left =\u0026gt; Orientation.West, }; Console.WriteLine($\u0026#34;Cardinal orientation is {orientation}\u0026#34;);   类型模式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public static T ExhaustiveExample\u0026lt;T\u0026gt;(IEnumerable\u0026lt;T\u0026gt; sequence) =\u0026gt; sequence switch { System.Array { Length : 0} =\u0026gt; default(T), System.Array { Length : 1} array =\u0026gt; (T)array.GetValue(0), System.Array { Length : 2} array =\u0026gt; (T)array.GetValue(1), System.Array array =\u0026gt; (T)array.GetValue(2), IEnumerable\u0026lt;T\u0026gt; list when !list.Any() =\u0026gt; default(T), IEnumerable\u0026lt;T\u0026gt; list when list.Count() \u0026lt; 3 =\u0026gt; list.Last(), IList\u0026lt;T\u0026gt; list =\u0026gt; list[2], null =\u0026gt; throw new ArgumentNullException(nameof(sequence)), _ =\u0026gt; sequence.Skip(2).First(), };   _ 模式与未匹配的所有输入相匹配。 它必须在 null 检查之后执行，否则将与 null 输入匹配。\n","description":"","id":5,"section":"posts","tags":["dotnet","keyword"],"title":"C# 语句关键字（一）：switch","uri":"https://letgo.cc/posts/dotnet/keyword/switch/"},{"content":"很久没有用 Go 写代码了。以前 Go 和 Python 的包管理是我最讨厌的事。 Go 总有很多包无法下载，需要科学上网，或者自己下载替换。Python 要想用好包管理就要装虚拟环境，麻烦！\n现在 Go Modules 出来了，配合 GOPROXY 简直神器！\n具体怎么用不写了，自行 Google 吧。\n值得一提的是，我不是用 Goland 开发的嘛。众所周知的原因它过期了。于是我来这里看了看，又去公众号看了看，接着又发了个“?” 到后台，你猜发生了什么事？\n如果有什么不懂的，记住，百度知道。\n","description":"","id":6,"section":"posts","tags":["golang","gomodules"],"title":"Go Modules","uri":"https://letgo.cc/posts/go/2020-08-14-go-modules/"},{"content":"项目需要在线浏览 Office 文件，以前用过 SharePoint ，现在有 Office Online Server 可以处理。但是OOS安装配置比较复杂且需要 Windows 的服务器，不合适。一番查找，最后发现 ONLYOFFICE 的功能就是我需要的，马上部署！\n为了方便，就采用Docker镜像部署的方式\n创建容器 首先我们必须安装有Docker（假设Docker宿主机IP：192.168.1.2），然后进入网页 Docker安装帮助文档，创建容器：\n1  sudo docker run -i -t -d -p 9080:80 --restart=always onlyoffice/documentserver   在生产环境，数据不要存储在容器内，就自行创建保存目录，并使用以下命令：\n1 2 3 4 5  sudo docker run -i -t -d -p 9080:80 --restart=always \\  -v /app/onlyoffice/DocumentServer/logs:/var/log/onlyoffice \\  -v /app/onlyoffice/DocumentServer/data:/var/www/onlyoffice/Data \\  -v /app/onlyoffice/DocumentServer/lib:/var/lib/onlyoffice \\  -v /app/onlyoffice/DocumentServer/db:/var/lib/postgresql onlyoffice/documentserver    /var/log/onlyoffice for Document Server logs /var/www/onlyoffice/Data for certificates /var/lib/onlyoffice for file cache /var/lib/postgresql for database  查看是否成功 浏览器访问宿主IP+端口（http://192.168.1.2:9080），如果出现以下字样代表容器运行正常\n建立文档编辑HTML页面 创建一个html文件\n  嵌入编辑器\n1  \u0026lt;div id=\u0026#34;placeholder\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;     引用 js\n1  \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;http://192.168.1.2:9080/web-apps/apps/api/documents/api.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;     设置编辑器的参数，具体参数含义查看这里\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  config = { \u0026#34;document\u0026#34;: { \u0026#34;fileType\u0026#34;: \u0026#34;XLSX\u0026#34;, \u0026#34;info\u0026#34;: { \u0026#34;folder\u0026#34;: \u0026#34;Example Files\u0026#34;, \u0026#34;owner\u0026#34;: \u0026#34;John Smith\u0026#34;, \u0026#34;sharingSettings\u0026#34;: [ { \u0026#34;permissions\u0026#34;: \u0026#34;Full Access\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;John Smith\u0026#34; }, { \u0026#34;permissions\u0026#34;: \u0026#34;Read Only\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;Kate Cage\u0026#34; }, ], \u0026#34;uploaded\u0026#34;: \u0026#34;2010-07-07 3:46 PM\u0026#34; }, \u0026#34;key\u0026#34;: \u0026#34;12NaaaaAFE2\u0026#34;, //每个文档唯一的KEY \u0026#34;title\u0026#34;: \u0026#34;test6.docx\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://bugs.red/201901.XLSX\u0026#34;, //文档的地址 \u0026#34;permissions\u0026#34;: { //权限 \u0026#34;comment\u0026#34;: false, \u0026#34;download\u0026#34;: false, \u0026#34;edit\u0026#34;: true, \u0026#34;fillForms\u0026#34;: false, \u0026#34;modifyContentControl\u0026#34;: false, \u0026#34;modifyFilter\u0026#34;: false, \u0026#34;print\u0026#34;: false, \u0026#34;review\u0026#34;: true }, }, \u0026#34;documentType\u0026#34;: \u0026#34;spreadsheet\u0026#34;, // WORD:text，PPT:presentation //\u0026#34;width\u0026#34;: \u0026#34;1600px\u0026#34;, \u0026#34;height\u0026#34;: \u0026#34;900px\u0026#34;, \u0026#34;editorConfig\u0026#34;: { // \u0026#34;actionLink\u0026#34;: ACTION_DATA, \u0026#34;callbackUrl\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;createUrl\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;customization\u0026#34;: { \u0026#34;autosave\u0026#34;: false, \u0026#34;chat\u0026#34;: false, \u0026#34;commentAuthorOnly\u0026#34;: false, \u0026#34;comments\u0026#34;: false, \u0026#34;compactHeader\u0026#34;: false, \u0026#34;compactToolbar\u0026#34;: false, \u0026#34;customer\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;My City, 123a-45\u0026#34;, \u0026#34;info\u0026#34;: \u0026#34;Some additional information\u0026#34;, \u0026#34;logo\u0026#34;: \u0026#34;https://example.com/logo-big.png\u0026#34;, \u0026#34;mail\u0026#34;: \u0026#34;john@example.com\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Smith and Co.\u0026#34;, \u0026#34;www\u0026#34;: \u0026#34;example.com\u0026#34; }, \u0026#34;feedback\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://example.com\u0026#34;, \u0026#34;visible\u0026#34;: false }, \u0026#34;forcesave\u0026#34;: false, \u0026#34;goback\u0026#34;: { \u0026#34;blank\u0026#34;: false, \u0026#34;requestClose\u0026#34;: true, \u0026#34;text\u0026#34;: \u0026#34;Open file location\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://bugs.red/\u0026#34; }, \u0026#34;help\u0026#34;: false, \u0026#34;hideRightMenu\u0026#34;: true, \u0026#34;logo\u0026#34;: { \u0026#34;image\u0026#34;: \u0026#34;https://bugs.red/favicon-32x32.png\u0026#34;, \u0026#34;imageEmbedded\u0026#34;: \u0026#34;https://bugs.red/favicon-32x32.png\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://bugs.red/\u0026#34; }, \u0026#34;mentionShare\u0026#34;: false, \u0026#34;reviewDisplay\u0026#34;: \u0026#34;original\u0026#34;, \u0026#34;showReviewChanges\u0026#34;: false, \u0026#34;spellcheck\u0026#34;: false, \u0026#34;toolbarNoTabs\u0026#34;: true, \u0026#34;unit\u0026#34;: \u0026#34;cm\u0026#34;, \u0026#34;zoom\u0026#34;: 100 }, \u0026#34;embedded\u0026#34;: { \u0026#34;embedUrl\u0026#34;: \u0026#34;https://example.com/embedded?doc=exampledocument1.docx\u0026#34;, \u0026#34;fullscreenUrl\u0026#34;: \u0026#34;https://example.com/embedded?doc=exampledocument1.docx#fullscreen\u0026#34;, \u0026#34;saveUrl\u0026#34;: \u0026#34;https://example.com/download?doc=exampledocument1.docx\u0026#34;, \u0026#34;shareUrl\u0026#34;: \u0026#34;https://example.com/view?doc=exampledocument1.docx\u0026#34;, \u0026#34;toolbarDocked\u0026#34;: \u0026#34;top\u0026#34; }, \u0026#34;lang\u0026#34;: \u0026#34;zh-cn\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;edit\u0026#34;, }\t, \u0026#34;type\u0026#34;: \u0026#34;desktop\u0026#34;, \u0026#34;width\u0026#34;: \u0026#34;100%\u0026#34; };    实例化编辑器  1  var docEditor = new DocsAPI.DocEditor(\u0026#34;placeholder\u0026#34;, config);   最终效果 相关链接 ONLYOFFICE 社区版下载地址\nONLYOFFICE API 基本设置\n","description":"","id":7,"section":"posts","tags":["onlyoffice","office","docker"],"title":"用 ONLYOFFICE 在线查看Word Excel PPT","uri":"https://letgo.cc/posts/docker/2020-08-11-onlyoffice/"},{"content":"前言 有一些服务想要部署，但是没有那么多的测试环境。用 VirtualBox 的话占用的资源也不少。想起之前看过 WSL 的介绍，说启动一个Linux只需要几十M的内存！话不多说，搞起！\n启用 WSL 以管理员身份打开 PowerShell ：\n1 2  dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart   更新到 WSL 2（可选）   升级 Windows\nWindows 10 Version 2004 以上的版本才能安装 WSL 2。可以运行 winver 查看自己的版本。\n下载 更新工具 进行更新\n  启用“虚拟机平台”可选组件\n  1  dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart    升级 WSL2 Linux 内核\n要使用 WSL 2 必须先下载 WSL 2 Linux 内核更新包安装即可。官方教程 x64安装包 arm64安装包\n  将 WSL 2 设置为默认版本\n  1  wsl --set-default-version 2\t  安装 Linux 打开 Windows Store 搜索 Ubuntu 下载安装即可\n","description":"","id":8,"section":"posts","tags":["WSL2"],"title":"Windows 10 安装 WSL2","uri":"https://letgo.cc/posts/windows/2020-08-30-install-wsl/"},{"content":"想要备份一些技术文章和资料，很多博客都是php或要求数据库，找了一圈发现 Hugo 不错，单一文件，还是 golang 写的。\n具体怎么使用搜索一下一大堆，这里写一下别的。\n修改 Themes 后怎么编译 修改了别人的 scss 文件的话需要下载 extended 版本的hugo才能正常编译。只是修改HTML的话就不用。\n显示行号、代码高亮 lineos  代表显示行号。\n hl_line 代表代码里需要高亮的行，[2,3,5-7]表示第2、3、5至7 行都高亮。\nlinenostart 表示行号从199开始，这里的行号跟高亮的行无关。\n1 2 3  ​``` csharp {linenos=inline,hl_lines=[2,3,5-7],linenostart=199} dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart ​```   支持高亮的类型  actionscript、actionscript3 actionscript, actionscript3, as, as3 Angular2 ng2 ApacheConf aconf, apache, apacheconf, conf, htaccess Bash bash, bash_*, bashrc, ebuild, eclass, exheres-0, exlib, ksh, sh, shell, zsh, zshrc Batchfile bat, batch, cmd, dosbatch, winbatch C c, h, idc C# c#, cs, csharp C++ C, CPP, H, c++, cc, cp, cpp, cxx, h++, hh, hpp, hxx CSS css Docker docker, dockerfile Go go, golang HTML htm, html, xhtml, xslt PHP inc, php, php3, php4, php5, php[345] PowerShell posh, powershell, ps1, psm1 Python py, python, pyw, sage, sc, tac, py3, python3 其他 json, java, javascript, js, kotlin, lua, mysql, sql, objective-c, vue, vuewjs ,txt  Github Webhook 想要偷懒，在GitHub Push/Comment 后自动生成 Blog，以下是Golang的代码\n  main.go\n监听3000端口，提供一个接口 /githubhook 。在GitHub新建一个 Webhooks 指向此处即可。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134  package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;gopkg.in/go-playground/webhooks.v5/github\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;strings\u0026#34; ) const ( path = \u0026#34;/githubhook\u0026#34; conf = \u0026#34;app.conf\u0026#34; ) func main() { hook, _ := github.New(github.Options.Secret(\u0026#34;eddyyuenblog\u0026#34;)) http.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) { payload, err := hook.Parse(r, github.IssueCommentEvent, github.PushEvent) if err != nil { if err == github.ErrEventNotFound { // ok event wasn;t one of the ones asked to be parsed \t_, _ = w.Write([]byte(\u0026#34;EventNotFound!\u0026#34;)) } else { _, _ = w.Write([]byte(\u0026#34;Error!\u0026#34;)) } return } switch payload.(type) { case github.IssueCommentPayload: //IssueComment := payload.(github.IssueCommentPayload) \t// todo 发送回复的通知 \t//fmt.Printf(\u0026#34;%+v\u0026#34;, IssueComment) \tfmt.Printf(\u0026#34;github.IssueComment\u0026#34;) _, _ = w.Write([]byte(\u0026#34;ok!\u0026#34;)) case github.PushPayload: //pushRequest := payload.(github.PushPayload) \t// todo pull github \u0026amp; run hugo.exe \trunCommand() fmt.Printf(\u0026#34;github.PushPayload\u0026#34;) _, _ = w.Write([]byte(\u0026#34;ok!\u0026#34;)) default: _, _ = w.Write([]byte(\u0026#34;NOT HANDLER!\u0026#34;)) } }) _ = http.ListenAndServe(\u0026#34;:3000\u0026#34;, nil) } func runCommand() { dir, _ := os.Executable() exPath := filepath.Dir(dir) //读取文件的信息 \tbytes, err := ioutil.ReadFile(exPath+\u0026#34;\\\\\u0026#34;+conf) if err != nil { fmt.Println(err.Error()) return } //按照换行符分割 \ttext := string(bytes) cmdarr := strings.Split(text, \u0026#34;\\r\\n\u0026#34;) //是否新的开始 \tisBegin := 1 for _, val := range cmdarr { tmpval := strings.TrimSpace(val) //如果是新命令开始，那么是切换目录操作 \tif tmpval != \u0026#34;\u0026#34; \u0026amp;\u0026amp; isBegin == 1 { os.Chdir(tmpval) } else if tmpval != \u0026#34;\u0026#34; { //分割命令 \tcmdarr := strings.Split(tmpval, \u0026#34; \u0026#34;) //命令名称 \tcommand := cmdarr[0] //命令参数 \tparams := cmdarr[1:] //执行cmd命令 \texecCommand(command, params) } //如果是空行，说明新的命令开始 \tif tmpval == \u0026#34;\u0026#34; { isBegin = 1 continue } else { isBegin = 0 } } } //执行命令函数 //commandName 命名名称，如cat，ls，git等 //params 命令参数，如ls -l的-l，git log 的log等 //注：本函数转载#http://studygolang.com/articles/4004 func execCommand(commandName string, params []string) bool { cmd := exec.Command(commandName, params...) //显示运行的命令 \tfmt.Println(cmd.Args) stdout, err := cmd.StdoutPipe() if err != nil { fmt.Println(err) return false } cmd.Start() reader := bufio.NewReader(stdout) //实时循环读取输出流中的一行内容 \tfor { line, err2 := reader.ReadString(\u0026#39;\\n\u0026#39;) if err2 != nil || io.EOF == err2 { break } fmt.Println(line) } cmd.Wait() return true }     app.conf\n获取最新的代码，然后调用 Hugo 生成站点，最后复制到网站的目录。\n2D:\\Webapplication\\Hugo\\sites\\blog 3git fetch 4git merge origin 5 6D:\\Webapplication\\Hugo\\sites\\blog 7D:\\Webapplication\\Hugo\\sites\\hugo.exe 8 9D:\\Webapplication\\Hugo\\sites\\blog 10xcopy D:\\Webapplication\\Hugo\\sites\\blog\\public D:\\Webapplication\\Hugo\\sites\\public /e /k /y   ","description":"","id":9,"section":"posts","tags":["blog","hugo"],"title":"使用 Hugo 建立博客","uri":"https://letgo.cc/posts/go/blog/2020-07-30-hugo-install/"},{"content":"又又又立 flag 了！\n每次有新的东东出来的时候，就会立 flag ，这次也不例外。\n年底前要达成的目标  体重目前 80KG，目标 70KG； 公众号15篇原创文章； .NET Core 做一个集成各种常用功能的项目，开箱即用； 学弹钢琴，能完整弹奏任意一首曲目。  奖品 以上如果每有一条达不到，微信公众号就提供一份不少于￥200的奖品进行抽奖！\n立此为证！！\n","description":"","id":10,"section":"posts","tags":["flag"],"title":"又又又立 Flag 了","uri":"https://letgo.cc/posts/2020-07-30-flag-again/"},{"content":"简介 不小心入了软件开发这个行当，当时只是为了玩游戏而已！\n玩了两年游戏以为自己喜欢电脑就报了计算机，从此发际线就慢慢远离我。\n只会一两种语言，.Net 和 Go ，不熟，会用而已。\n现状 有个公众号，没粉丝，偶尔写一篇。\n只想赚钱。\n学赚钱中。\n","description":"半吊子程序员","id":11,"section":"","tags":null,"title":"关于","uri":"https://letgo.cc/about/"},{"content":"阿阿嘎\n啊发发\n","description":"Hugo, the world’s fastest framework for building websites","id":12,"section":"","tags":null,"title":"最新评论","uri":"https://letgo.cc/comments/"}]